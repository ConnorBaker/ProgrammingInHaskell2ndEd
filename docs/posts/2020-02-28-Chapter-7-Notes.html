<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bumbling Through Haskell - Chapter 7</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;0,900;1,400;1,700;1,900&display=swap">
    <link rel="stylesheet" href="../css/blog.css">
</head>

<body class="background-default">
    <div class="flex flex-row justify-between p-4 text-3xl text-white font-black">
        <div class="backdrop-blur-xl backdrop-brightness-75 rounded-full p-4">
            <span class="sr-only">The identity function written as a lambda with bee emoji</span>
            Œª üêù . üêù
        </div>
        <div class="p-4">
            <span class="sr-only">Go to blog on GitHub</span>
            <a href="https://github.com/ConnorBaker/ProgrammingInHaskell2ndEd" class="text-white">
                <svg width="32" height="32" viewBox="0 0 16 16" fill="currentColor">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                    </path>
                </svg>
            </a>
        </div>
    </div>


    <div class="spacing-defaults text-defaults">
        <div id="header" class="text-center text-white space-y-4">
            <div class="text-7xl font-display font-black">
                Bumbling Through Haskell
            </div>
            <div class="text-xl">
                Miscellaneous thoughts and notes on Haskell
            </div>
        </div>

        <nav class="p-4 w-fit mx-auto h-18 text-black bg-lime-50 rounded-full">
            <div class="flow-root">
                <div class="flex items-center space-x-4">
                    <!-- TODO: Use some distinctive visual style to indicate the current page -->
                    <a href="../" class="clickable-light-bg px-3 py-2 rounded-full">Posts</a>

                    <a href="../about.html" class="clickable-light-bg px-3 py-2 rounded-full">About</a>

                    <a href="../archive.html" class="clickable-light-bg px-3 py-2 rounded-full">Archive</a>
                </div>
            </div>
        </nav>

        <div class="post-box">
    <div class="post-title">
        <a href="../posts/2020-02-28-Chapter-7-Notes.html">Chapter 7</a>
    </div>
    <div class="post-subtitle">
        Higher-Order Functions
    </div>
    <div class="flow-root">
        <a class="post-pill-button-short" href="https://github.com/connorbaker">Connor Baker</a>
        <span class="float-right">February 28, 2020</span>
    </div>
    <h2 id="basic-concepts">7.1 Basic Concepts</h2>
<p>Functions with multiple arguments are defined with currying (which is part of why we have right-associative groupings for parameters). As an example, we can rewrite</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>add xy <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>as</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>add <span class="ot">=</span> \x <span class="ot">-&gt;</span> (\y <span class="ot">-&gt;</span> x <span class="op">+</span> y)</span></code></pre></div>
<p>which makes it clear that add is a function that takes an integer and returns another function which takes an integer and maps to the sum <code>x + y</code>. <!--more--> As an example, a function which takes as arguments a function and a value and returns the result of the application of the function to the value could be written as</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">applyMe ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>applyMe f x <span class="ot">=</span> f x</span></code></pre></div>
<p>As a result of using curried functions to define multi-argument functions, we can use partial application. Consider the following function <code>succ</code> which yields the successor of a natural number:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">succ</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">succ</span> <span class="ot">=</span> applyMe (<span class="op">+</span><span class="dv">1</span>)</span></code></pre></div>
<p>As a definition, a function which takes multiple arguments or maps to a function (that is to say that it <em>returns</em> a function) is called a <em>higher-order function</em>. We have a small conflict as <em>curried</em> functions return functions, and so within the context of Haskell we take higher-order functions to mean functions which takes arguments that are functions.</p>
<h2 id="processing-lists">7.2 Processing Lists</h2>
<p>One of the more commonly used functions in Haskell‚Äôs standard library, <code>map</code> takes a function as an argument and applies it to every element of a list. It can be defined as</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f xs <span class="ot">=</span> [f x <span class="op">|</span> x <span class="ot">&lt;-</span> xs]</span></code></pre></div>
<p>The <code>map</code> function is described a <em>polymorphic</em> because it can be applied to lists of any type.</p>
<p>As an aside, with the previous chapter‚Äôs focus on recursion behind us, we could re-write map as a recursive function if we so chose to:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f []     <span class="ot">=</span> []</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">map</span> f xs</span></code></pre></div>
<p>The <code>map</code> function can also be applied to itself to operate on a list of lists. As an example, if we had a list of lists of integers and we wished to double every value, we could define <code>deepDouble</code> to do so:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deepDouble ::</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>deepDouble <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="op">*</span><span class="dv">2</span>))</span></code></pre></div>
<p>The <code>filter</code> function is another useful higher-order function included in Haskell‚Äôs standard library:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span> p xs <span class="ot">=</span> [x <span class="op">|</span> x <span class="ot">&lt;-</span> xs, p x]</span></code></pre></div>
<p>The function <code>filter</code> creates a list of all the element from the list passed in as an argument which satisfy the predicate <code>p</code>.</p>
<p>As an example, if we wanted to remove all the of the spaces in a <code>String</code> we could do</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">filter</span> (<span class="op">/=</span> <span class="ch">' '</span>) <span class="st">&quot;a toddler wrote me&quot;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;atoddlerwroteme&quot;</span></span></code></pre></div>
<p>As another exercise in recursion, we can write <code>filter</code> as a recursive function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span> p [] <span class="ot">=</span> []</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span> p (x<span class="op">:</span>xs)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> p x       <span class="ot">=</span> x <span class="op">:</span> <span class="fu">filter</span> p xs</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">filter</span> p xs</span></code></pre></div>
<p>Typically, <code>map</code> and <code>filter</code> are used in conjunction: <code>filter</code> is applied to a list to remove undesirable elements, and then <code>map</code> is invoked on the result.</p>
<p>There are several other higher-order functions present in Prelude which are worth mentioning:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">all</span> <span class="fu">even</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">any</span> <span class="fu">odd</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">takeWhile</span> <span class="fu">even</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">8</span>]</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,<span class="dv">4</span>]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">dropWhile</span> <span class="fu">even</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">8</span>]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">8</span>]</span></code></pre></div>
<h2 id="the-foldr-function">7.3 The foldr Function</h2>
<p>As you probably noticed from the examples above, most functions that operate on lists can be defined using a simple recursive pattern:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>f []     <span class="ot">=</span> v</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>f (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">?</span> f xs</span></code></pre></div>
<p>where <code>v</code> is some value, and <code>?</code> is some operator.</p>
<p>For practice, we redefine the <code>sum</code>, <code>product</code>, <code>or</code>, and <code>and</code> functions to operate on lists:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">+</span> <span class="fu">sum</span> xs</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">product</span> [] <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="fu">product</span> (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">*</span> <span class="fu">product</span> xs</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span> [] <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span> (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">||</span> <span class="fu">or</span> xs</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">&amp;&amp;</span> <span class="fu">and</span> xs</span></code></pre></div>
<p>Given how similar the definition of all of these functions are, you would think that we can make a function that applies some sort of operation recursively‚Ä¶ and you‚Äôd be right! Enter: <code>foldr</code>.</p>
<p>The higher-order library function <code>foldr</code> works using the simple recursive pattern above, taking as arguments <code>?</code> and <code>v</code>. Redefining the functions above, we can write each of them in a single line (if we omit the type annotation, which is inferred by the compiler anyways):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">+</span>) <span class="dv">0</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">product</span> <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">*</span>) <span class="dv">1</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span> <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">||</span>) <span class="dt">False</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">&amp;&amp;</span>) <span class="dt">True</span></span></code></pre></div>
<p><em>Note: Remember that operators need to be parenthesized when used as arguments.</em></p>
<p>Probably unsurprisingly, the <code>foldr</code> function can also be defined using recursion (though the type annotation might be surprising):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f v [] <span class="ot">=</span> v</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f v (x<span class="op">:</span>xs) <span class="ot">=</span> f x (<span class="fu">foldr</span> f v xs)</span></code></pre></div>
<p>Let‚Äôs break down the type of <code>foldr</code> (I myself didn‚Äôt understand it until I read <a href="https://stackoverflow.com/a/11425454" class="uri">https://stackoverflow.com/a/11425454</a>, which also helps explain how the <code>length</code> function could be rewritten in terms of <code>foldr</code>).</p>
<p>We can see that there are three arguments: a function, the starting value of an accumulator, and a list. The function argument takes an element of a list (the <code>a</code>), an accumulator (that‚Äôs the first <code>b</code>), and returns the accumulator. After execution, <code>foldr</code> returns the result of the accumulator.</p>
<p>As an example of how <code>foldr</code> is applied, consider the following: <code>foldr (+) 0 [1,2,3]</code> is equivalent to <code>foldr (+) 0 1:(2:(3:[]))</code> which, after the application of <code>foldr</code>, turns into the expression <code>1+(2+(3+0))</code>.</p>
<p>As an example, let‚Äôs re-write the library functions <code>length</code> and <code>reverse</code> using <code>foldr</code>.</p>
<p>We know that <code>length</code> is defined as</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> []     <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (_<span class="op">:</span>xs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">length</span> xs</span></code></pre></div>
<p>We start by constructing the first argument of <code>foldr</code>. Just like the definition above, we shouldn‚Äôt care what elements of the list we‚Äôre dealing with. We know that our accumulator will be a number, and that the accumulator should increase by one after each element is processed. As such, we end up with the lambda <code>(\_ n -&gt; 1 + n)</code>.</p>
<p>Keep in mind that the <code>\</code> only indicates that we‚Äôre declaring a lambda function, not that <code>_</code> is the only argument of the lambda function.</p>
<p>The second argument of <code>foldr</code> is the value that the accumulator starts at, which will be zero, per the definition of <code>length</code> (in the case that the list is empty, <code>foldr</code> has no elements to operate on, so it returns the initial value of the accumulator). All together, we have</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> <span class="ot">=</span> <span class="fu">foldr</span> (\_ n <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">+</span> n) <span class="dv">0</span></span></code></pre></div>
<p>We don‚Äôt need to write the list <code>xs</code> on either side since we can take advantage of partial application (alternatively, we can say that <code>length</code> is a mapping <em>defined by</em> <code>foldr (\_ n -&gt; 1 + n) 0</code>).</p>
<p>For a more thorough explanation, consult <a href="https://stackoverflow.com/a/11425454" class="uri">https://stackoverflow.com/a/11425454</a>.</p>
<p>We know that the definition of reverse is</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> []     <span class="ot">=</span> []</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">reverse</span> xs <span class="op">++</span> [x]</span></code></pre></div>
<p>To better get a sense of how we might re-write it with <code>foldr</code>, let‚Äôs work through an example. If we have the list <code>1 : (2 : (3 : []))</code> and we invoke reverse, we have <code>(([] ++ [3]) ++ [2]) ++ [1]</code>.</p>
<p>We can see that the result is equivalent to concatenating each element to the end of a list: <code>3:(2:(1:[]))</code>.</p>
<p>Beginning again by constructing the function argument of <code>fodlr</code>, we have <code>(\x y -&gt; y ++ [x])</code>.</p>
<p><em>Note: We must use <code>[x]</code> because <code>x</code> is not a list, and <code>(++)</code> is only defined to work on lists.</em></p>
<p>The default value of the accumulator in this case is the empty set, so our definition of <code>reverse</code> in terms of <code>foldr</code> is</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> <span class="ot">=</span> <span class="fu">foldr</span> (\x y <span class="ot">-&gt;</span> y <span class="op">++</span> [x]) []</span></code></pre></div>
<p>The function is called <code>foldr</code> because it is assumed that the function passed as an argument is right-associative. In general, the behavior of <code>foldr</code> is summarized as</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> (<span class="op">?</span>) v [x0,x1,<span class="op">...</span>,xn] <span class="ot">=</span> x0 <span class="op">?</span> (x1 <span class="op">?</span> (<span class="op">...</span> (xn <span class="op">?</span> v) <span class="op">...</span>))</span></code></pre></div>
<h2 id="the-foldl-function">7.4 The foldl Function</h2>
<p>Just like we have a <code>foldr</code>, we have a function that handles left-associative operators: <code>foldl</code>. Instead of the simple recursive pattern we identified in the previous section, consider the following pattern:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>f v [] <span class="ot">=</span> v</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>f v (x<span class="op">:</span>xs) <span class="ot">=</span> f (v <span class="op">?</span> x) xs</span></code></pre></div>
<p>Just as we redefined the <code>sum</code>, <code>product</code>, <code>or</code>, <code>and</code>, <code>length</code>, and <code>reverse</code> functions in terms of <code>foldr</code>, we can do the same for them in terms of <code>foldl</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="ot">=</span> <span class="fu">foldl</span> (<span class="op">+</span>) <span class="dv">0</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="fu">product</span> <span class="ot">=</span> <span class="fu">foldl</span> (<span class="op">*</span>) <span class="dv">1</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="fu">or</span> <span class="ot">=</span> <span class="fu">foldl</span> (<span class="op">||</span>) <span class="dt">False</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span> <span class="ot">=</span> <span class="fu">foldl</span> (<span class="op">&amp;&amp;</span>) <span class="dt">True</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> <span class="ot">=</span> <span class="fu">foldl</span> (\n _ <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">+</span> n) <span class="dv">0</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> <span class="ot">=</span> <span class="fu">foldl</span> (\x y <span class="ot">-&gt;</span> y<span class="op">:</span>x) []</span></code></pre></div>
<p><em>Note: The first four functions didn‚Äôt have to change anything other than the type of fold because those operators are associative.</em></p>
<p><em>Note: The choice of which function to use when both work for a given operator is driven by a need for efficiency, which requires consideration of the evaluation mechanism Haskell uses.</em></p>
<p>We can define <code>foldl</code> using recursion, just like we did for <code>foldr</code></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f v []     <span class="ot">=</span> v</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f v (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">foldl</span> f (f v x) xs</span></code></pre></div>
<p>The function <code>foldl</code> can be summarized as</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> <span class="op">?</span> v [x0,x1,<span class="op">...</span>,xn] <span class="ot">=</span>  (<span class="op">...</span> ((v <span class="op">?</span> xn) <span class="op">?</span> x1) <span class="op">...</span>) <span class="op">?</span> x0</span></code></pre></div>
<h2 id="the-composition-operator">7.5 The Composition operator</h2>
<p>The higher-order library operator <code>.</code> returns the composition of two functions as a single function. It can be defined as</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> g <span class="ot">=</span> \x <span class="ot">-&gt;</span> f (g x)</span></code></pre></div>
<p>We could also have written the definition as <code>(f . g) x = f (g x)</code>, but the definition above uses a lambda to make clear the fact that <code>(.)</code> returns a function.</p>
<p>One use of composition is to reduce the number of parenthesis in your code. We could write <code>sumCubeOfOdd = sum (map (^3) (filter odd))</code> as <code>sumCubeOfOdd = sum . map (^3) . filter odd</code>.</p>
<p>Composition has an identity:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> <span class="ot">=</span> \x <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>The identity is a good place to start when trying to work with a sequence of compositions. Consider the composition of a list of functions:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">compose ::</span> [a <span class="ot">-&gt;</span> a] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>compose <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">.</span>) <span class="fu">id</span></span></code></pre></div>
<h2 id="binary-string-transmitter">7.6 Binary String Transmitter</h2>
<p>The rest of the chapter consists of two longer programming exercises. The first is about simulating the transmission of a string of characters as a list of binary digits.</p>
<h3 id="binary-numbers">Binary Numbers</h3>
<p>Omitted as I assume that my readers are familiar with the topic. If not, consult some other sources; I like Wolfram Mathworld for all topics related to mathematics (here‚Äôs their entry on <a href="http://mathworld.wolfram.com/Binary.html">Binary Numbers</a>).</p>
<p>The one take away from this section was that we can express a number as a sum of its digits to powers of the index of the digit. Generalizing this concept we have the concept of the <span class="math inline"><em>Œ≤</em></span>-expansion (or radix-point-expansion). It states that a number <span class="math inline"><em>n</em></span> with <span class="math inline"><em>i</em></span> digits <span class="math inline"><em>n</em><sub><em>i</em>‚ÄÖ‚àí‚ÄÖ1</sub>‚Ä¶<em>n</em><sub>0</sub></span> in base <span class="math inline"><em>Œ≤</em></span> can be written as</p>
<p><span class="math display"><em>n</em>‚ÄÑ=‚ÄÑ<em>n</em><sub><em>i</em>‚ÄÖ‚àí‚ÄÖ1</sub>‚ÄÖ√ó‚ÄÖ<em>Œ≤</em><sup><em>i</em>‚ÄÖ‚àí‚ÄÖ1</sup>‚ÄÖ+‚ÄÖ‚Ä¶‚ÄÖ+‚ÄÖ<em>n</em><sub>0</sub>‚ÄÖ√ó‚ÄÖ<em>Œ≤</em><sup>0</sup></span></p>
<p>If you prefer summation notation, it would be</p>
<p><span class="math display">$$
n = \sum_{k=0}^{i-1}n_{k}\times\beta^k
$$</span></p>
<p>So if we had a number <span class="math inline">101.1001<sub><em>œÜ</em></sub></span>, where <span class="math inline"><em>œÜ</em></span> is the golden ratio (base golden ratio, also called <a href="https://en.wikipedia.org/wiki/Golden_ratio_base">Phinary</a>, has some interesting properties), can be written as</p>
<p><span class="math display">1‚ÄÖ√ó‚ÄÖ<em>œÜ</em><sup>2</sup>‚ÄÖ+‚ÄÖ0‚ÄÖ√ó‚ÄÖ<em>œÜ</em><sup>2</sup>‚ÄÖ+‚ÄÖ1‚ÄÖ√ó‚ÄÖ<em>œÜ</em><sup>0</sup>‚ÄÖ+‚ÄÖ1‚ÄÖ√ó‚ÄÖ<em>œÜ</em><sup>‚àí1</sup>‚ÄÖ+‚ÄÖ0‚ÄÖ√ó‚ÄÖ<em>œÜ</em><sup>‚àí2</sup>‚ÄÖ+‚ÄÖ0‚ÄÖ√ó‚ÄÖ<em>œÜ</em><sup>‚àí3</sup>‚ÄÖ+‚ÄÖ1‚ÄÖ√ó‚ÄÖ<em>œÜ</em><sup>‚àí4</sup></span></p>
<h3 id="base-conversion">Base Conversion</h3>
<p>Since we‚Äôll be dealing with characters, it‚Äôs prudent to add <code>import Data.Char</code> to our workspace.</p>
<p>To make the purpose of our functions more clear, we‚Äôll define a new <em>type</em> <code>Bit</code>, which will be a synonym for integers:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bit</span> <span class="ot">=</span> <span class="dt">Int</span></span></code></pre></div>
<p>A binary number is no different from any other type of number, and it is helpful to be able to convert them to decimal notation, so we define a function to do so</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bin2Int ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>bin2Int bits <span class="ot">=</span> <span class="fu">sum</span> [w<span class="op">*</span>b <span class="op">|</span> (w,b) <span class="ot">&lt;-</span> <span class="fu">zip</span> weights bits]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span> weights <span class="ot">=</span> <span class="fu">iterate</span> (<span class="op">*</span><span class="dv">2</span>) <span class="dv">1</span></span></code></pre></div>
<p>The higher-order library function <code>iterate</code> creates an infinite list by repeatedly applying a function to an initial value. Visually,</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">iterate</span> f x <span class="ot">=</span> [x, f x, (f <span class="op">.</span> f) x, (f <span class="op">.</span> f <span class="op">.</span> f) x]</span></code></pre></div>
<p><em>Note: Our function assumes that the binary input is <a href="https://en.wikipedia.org/wiki/Endianness">Little-Endian</a>; that is to say that the least significant bit (LSB) is at the lowest index. So in effect, our list is a ‚Äúnormal‚Äù binary number in reverse!</em></p>
<p>Let‚Äôs instead try to think of a more succinct. To do that, let‚Äôs trace what our ideal version of the function would do, for some four bit input <code>[a,b,c,d]</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> [a,b,c,d]</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="ot">-&gt;</span> (<span class="dv">1</span> <span class="op">*</span> a) <span class="op">+</span> (<span class="dv">2</span> <span class="op">*</span> b) <span class="op">+</span> (<span class="dv">4</span> <span class="op">*</span> c) <span class="op">+</span> (<span class="dv">8</span> <span class="op">*</span> d)</span></code></pre></div>
<p>It looks like high-school algebra, so let‚Äôs borrow a technique to manipulate it: factoring!</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">-&gt;</span> (<span class="dv">1</span> <span class="op">*</span> a) <span class="op">+</span> (<span class="dv">2</span> <span class="op">*</span> b) <span class="op">+</span> (<span class="dv">4</span> <span class="op">*</span> c) <span class="op">+</span> (<span class="dv">8</span> <span class="op">*</span> d)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="ot">-&gt;</span> a <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> (b <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> (c <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> (d <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">0</span>)))</span></code></pre></div>
<p>Well this looks familiar! (If it doesn‚Äôt go peek back at the summarized form of <code>foldr</code>.) Each element is being added to twice the second element, except for the last element.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bin2Int ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>bin2Int <span class="ot">=</span> <span class="fu">foldr</span> (\x y <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>y) <span class="dv">0</span></span></code></pre></div>
<p>Let‚Äôs also create a function that converts a non-negative integer to a binary sequence.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">int2Bin ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>int2Bin <span class="dv">0</span> <span class="ot">=</span> []</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>int2Bin n <span class="ot">=</span> <span class="fu">mod</span> n <span class="dv">2</span> <span class="op">:</span> int2Bin (<span class="fu">div</span> n <span class="dv">2</span>)</span></code></pre></div>
<p>For the purpose of this problem, we restrict all of our numbers to a constant length. We use the function</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">make8 ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>make8 bits <span class="ot">=</span> <span class="fu">take</span> <span class="dv">8</span> (bits <span class="op">++</span> <span class="fu">repeat</span> <span class="dv">0</span>)</span></code></pre></div>
<p>to truncate or pad our input (with zeros) to the correct length.</p>
<p><em>Note: Times like these are where the beauty of lazy evaluation comes in to play; lazy evaluation ensures that, even though repeat generates an infinite list, if bits is already eight elements or more, the list is not created.</em></p>
<h3 id="transmission">Transmission</h3>
<p>Having set up all the of the prerequisite functions, we can make a one-liner that takes a string of characters, converts each into a Unicode number, converts each number into binary, and concatenate the result. We‚Äôll name the function <code>encode</code>, because we‚Äôre real, and we call it like we see it.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">encode ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>encode <span class="ot">=</span> <span class="fu">concat</span> <span class="op">.</span> <span class="fu">map</span> (make8 <span class="op">.</span> int2Bin <span class="op">.</span> <span class="fu">ord</span>)</span></code></pre></div>
<p><em>Note: If you‚Äôve forgotten, <code>Data.Char</code>‚Äôs <code>ord</code> takes a character and returns the ASCII value.</em></p>
<p>To decode the result of <code>encode</code>, we need to split the list every eight elements, turn the binary number into a decimal value, and turn that decimal value into a character.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chop8 ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [[<span class="dt">Bit</span>]]</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>chop8 [] <span class="ot">=</span> []</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>chop8 bits <span class="ot">=</span> <span class="fu">take</span> <span class="dv">8</span> bits <span class="op">:</span> chop8 (<span class="fu">drop</span> <span class="dv">8</span> bits)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="ot">decode ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>decode <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">chr</span> <span class="op">.</span> bin2Int) <span class="op">.</span> chop8</span></code></pre></div>
<p>Lastly, let‚Äôs define a function that simulates transmitting a string of characters as a list of binary bits. To make things easier (and avoid digressing into a post about information theory), we‚Äôll assume that the transmission channel is perfect and implement it using the identity function:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">channel ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>channel <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="ot">transmit ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>transmit <span class="ot">=</span> decode <span class="op">.</span> channel <span class="op">.</span> encode</span></code></pre></div>
<h2 id="voting-algorithms">7.7 Voting Algorithms</h2>
<p>The second programming exercise looks at two algorithms for deciding the winner of an election: the first algorithm is the easy-to-implement <em>first past the post</em>; the second is the more refined <em>alternative vote</em> system.</p>
<h3 id="first-past-the-post">First Past the Post</h3>
<p>In this system, each person gets one vote, and the winner of the election is the candidate with the largest number of votes.</p>
<p>To implement this method, we‚Äôll need a function that counts the number of appearances of a value in a list, with the caveat that type is comparable.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">count ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>count x <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">==</span> x)</span></code></pre></div>
<p>We can also create a function which gives us a list of all the candidates that got any votes:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">candidates ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>candidates [] <span class="ot">=</span> []</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>candidates (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">:</span> <span class="fu">filter</span> (<span class="op">/=</span> x) (candidates xs)</span></code></pre></div>
<p>With these two functions, we can create a function which gives us the results of the vote:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">results ::</span> <span class="dt">Eq</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>,a)]</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>results votes <span class="ot">=</span> [(count v votes, v) <span class="op">|</span> v <span class="ot">&lt;-</span> candidates votes]</span></code></pre></div>
<p>If we want to sort the results, we can use the <code>sort</code> function provided by <code>Data.List</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sortedResults ::</span> <span class="dt">Ord</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>,a)]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>sortedResults votes <span class="ot">=</span> <span class="fu">sort</span> [(count v votes, v) <span class="op">|</span> v <span class="ot">&lt;-</span> candidates votes]</span></code></pre></div>
<p>We can find the winner by taking the second element of the last tuple:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">winner ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>winner <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> <span class="fu">last</span> <span class="op">.</span> result</span></code></pre></div>
<h3 id="alternative-vote">Alternative Vote</h3>
<p>In the alternative vote system, each person can vote for as many candidates as they want, but they must order them based on preference. (So their most desired candidate is first, and their least desired candidate is last.)</p>
<p>The winner is found by the following process:</p>
<ol type="1">
<li>Remove all the empty ballots</li>
<li>Remove the candidate that was chosen the fewest number of times as the first choice (this causes candidates on the ballot to shift left to fill the gap)</li>
<li>Repeat the process</li>
</ol>
<p>Creating a function that removes empty ballots isn‚Äôt too difficult</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rmEmpty ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>rmEmpty <span class="ot">=</span> <span class="fu">filter</span> (<span class="op">/=</span> [])</span></code></pre></div>
<p>Nor is creating a function that removes a given candidate from all the ballots</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">elimCandidate ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>elimCandidate x <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">filter</span> (<span class="op">/=</span> x))</span></code></pre></div>
<p>Because we defined all our functions in a general manner, we can reuse the <code>sortedResults</code> function from the previous section to help us with ranking candidates in each ballot</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rank ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> [a]</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>rank <span class="ot">=</span> <span class="fu">map</span> <span class="fu">snd</span> <span class="op">.</span> sortedResults <span class="op">.</span> <span class="fu">map</span> <span class="fu">head</span></span></code></pre></div>
<p>To implement the last step of the process which finds a winner, we can implement a recursive function which applies the first two steps.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">winnerAlt ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> a</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>winnerAlt ballots <span class="ot">=</span> <span class="kw">case</span> rank (rmEmpty ballots) <span class="kw">of</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    [c]    <span class="ot">-&gt;</span> c</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    (c<span class="op">:</span>cs) <span class="ot">-&gt;</span> winnerAlt (elimCandidate c ballots)</span></code></pre></div>
<p><em>Note: The <code>case</code> mechanism allows us to perform pattern matching in the body of a definition.</em></p>
<h2 id="chapter-remarks">7.8 Chapter Remarks</h2>
<p>There are several real-world applications of higher-order functions that crop up in common environments:</p>
<ul>
<li>Digital production of music</li>
<li>Financial contracts</li>
<li>Digital graphics</li>
<li>Hardware descriptions</li>
<li>Logic programs</li>
</ul>
</div>
    </div>
</body>

</html>