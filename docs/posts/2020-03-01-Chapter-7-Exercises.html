<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bumbling Through Haskell - Chapter 7 Exercises</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&display=swap">
    <link rel="stylesheet" href="../css/blog.css">
</head>

<body class="background-default">
    <div class="flex flex-row justify-between p-4 text-3xl text-white font-black">
        <div class="backdrop-blur-xl backdrop-brightness-75 rounded-full p-4">
            <span class="sr-only">The identity function written as a lambda with bee emoji</span>
            Œª üêù . üêù
        </div>
        <div class="p-4">
            <span class="sr-only">Go to blog on GitHub</span>
            <a href="https://github.com/ConnorBaker/ProgrammingInHaskell2ndEd" class="text-white">
                <svg width="32" height="32" viewBox="0 0 16 16" fill="currentColor">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                    </path>
                </svg>
            </a>
        </div>
    </div>


    <div class="spacing-defaults text-defaults">
        <div id="header" class="text-center text-white space-y-4">
            <div class="text-7xl font-display font-black">
                Bumbling Through Haskell
            </div>
            <div class="text-xl">
                Miscellaneous thoughts and notes on Haskell
            </div>
        </div>

        <nav class="p-4 w-fit mx-auto h-18 text-black bg-lime-50 rounded-full">
            <div class="flow-root">
                <div class="flex items-center space-x-4">
                    <!-- TODO: Use some distinctive visual style to indicate the current page -->
                    <a href="../" class="clickable-light-bg px-3 py-2 rounded-full">Posts</a>

                    <a href="../about.html" class="clickable-light-bg px-3 py-2 rounded-full">About</a>

                    <a href="../archive.html" class="clickable-light-bg px-3 py-2 rounded-full">Archive</a>
                </div>
            </div>
        </nav>

        <div class="post-box">
    <div class="post-title">
        <a href="../posts/2020-03-01-Chapter-7-Exercises.html">Chapter 7 Exercises</a>
    </div>
    <div class="post-subtitle">
        Higher-Order Functions
    </div>
    <div class="flow-root">
        <a class="post-pill-button-short" href="https://github.com/connorbaker">Connor Baker</a>
        <span class="float-right">March  1, 2020</span>
    </div>
    <h2 id="exercises">7.9 Exercises</h2>
<ol type="1">
<li><p>Show how the list comprehension <code>[f x | x &lt;- xs, p x]</code> can be re-expressed using the higher order functions <code>map</code> and <code>filter</code>.</p>
<p>Solution:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">applyFilterAndFnToList ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>applyFilterAndFnToList p f xs <span class="ot">=</span> <span class="fu">map</span> f (<span class="fu">filter</span> p xs)</span></code></pre></div>
<!--more--></li>
<li><p>Without looking at the definitions from the standard prelude, define the following higher-order library functions on lists:</p>
<ul>
<li><p>Decide if all the elements of a list satisfy a predicate:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div></li>
<li><p>Decide if any element of a list satisfies a predicate:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">any</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div></li>
<li><p>Select elements from a list while they satisfy a predicate</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span></code></pre></div></li>
<li><p>Remove elements from a list while they satisfy a predicate</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dropWhile</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span></code></pre></div></li>
</ul>
<p><em>Note: In <code>Prelude</code> the first two of these functions are generic functions rather than being specific to the type of lists</em></p>
<p>Solution:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Part a</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span> p <span class="ot">=</span> <span class="fu">and</span> <span class="op">.</span> <span class="fu">map</span> p</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Part b</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="fu">any</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="fu">any</span> p <span class="ot">=</span> <span class="fu">or</span> <span class="op">.</span> <span class="fu">map</span> p</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Part c</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span> _ [] <span class="ot">=</span> []</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span> p (x<span class="op">:</span>xs)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> p x         <span class="ot">=</span> x <span class="op">:</span> <span class="fu">takeWhile</span> p xs</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">=</span> []</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- Part d</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="fu">dropWhile</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="fu">dropWhile</span> _ [] <span class="ot">=</span> []</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="fu">dropWhile</span> p x'<span class="op">@</span>(x<span class="op">:</span>xs)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> p x       <span class="ot">=</span> <span class="fu">dropWhile</span> p xs</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x'</span></code></pre></div></li>
<li><p>Redefine the functions <code>map f</code> and <code>filter p</code> using <code>foldr</code>.</p>
<p>Solution:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">map' ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>map' f <span class="ot">=</span> <span class="fu">foldr</span> (\x xs <span class="ot">-&gt;</span> f x <span class="op">:</span> xs) []</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">filter' ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>filter' p <span class="ot">=</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">foldr</span> (\x xs <span class="ot">-&gt;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> p x <span class="kw">then</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                x<span class="op">:</span>xs</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">else</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                xs)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        []</span></code></pre></div></li>
<li><p>Using <code>foldl</code> define a function <code>dec2Int :: [Int] -&gt; Int</code> that converts a decimal number into an integer. For example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> dec2Int [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2345</span></span></code></pre></div>
<p>Solution:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dec2Int ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>dec2Int <span class="ot">=</span> <span class="fu">foldl</span> (\xs x <span class="ot">-&gt;</span> <span class="dv">10</span><span class="op">*</span>xs <span class="op">+</span> x) <span class="dv">0</span></span></code></pre></div></li>
<li><p>Without looking at the definitions from the standard prelude, define the higher-order library function <code>curry</code> that converts a function on pairs into a curried function, and, conversely, the function <code>uncurry</code> that converts a curried function with two arguments into a function on pairs. (Hint: first write down the types of the two functions.)</p>
<p>Solution:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">curry</span><span class="ot"> ::</span> ((a,b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">curry</span> f a b <span class="ot">=</span> f (a,b)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Alternatively:</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- curry f = \a b -&gt; f (a,b)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a,b) <span class="ot">-&gt;</span> c</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span> f (a,b) <span class="ot">=</span> f a b</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Alternatively:</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- uncurry f = \(a,b) -&gt; f a b</span></span></code></pre></div></li>
<li><p>A higher-order function <code>unfold</code> that encapsulates a simple pattern of recursion for producing a list can be defined as follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>unfold p h t x <span class="op">|</span> px        <span class="ot">=</span> []</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> h x <span class="op">:</span> unfold p h t (t x)</span></code></pre></div>
<p>That is, the function <code>unfold p h t</code> produces the empty list if the predicate <code>p</code> is true of the argument value, and otherwise produces a non-empty list by applying the function <code>h</code> to this value to give the head, and the function <code>t</code> to generate another argument that is recursively processed in the same way to produce the tail of the list. For example, the function <code>int2Bin</code> can be rewritten more compactly using <code>unfold</code> as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>int2Bin <span class="ot">=</span> unfold (<span class="op">==</span> <span class="dv">0</span>) (<span class="ot">`mod`</span> <span class="dv">2</span>) (<span class="ot">`div`</span> <span class="dv">2</span>)</span></code></pre></div>
<p>Redefine the functions <code>chop8</code>, <code>map f</code> and <code>iterate f</code> using <code>unfold</code>.</p>
<p>Solution:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unfold ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>unfold p h t x</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> p x       <span class="ot">=</span> []</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> h x <span class="op">:</span> unfold p h t (t x)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">chop8 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>chop8 <span class="ot">=</span> unfold <span class="fu">null</span> (<span class="fu">take</span> <span class="dv">8</span>) (<span class="fu">drop</span> <span class="dv">8</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="ot">map'' ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>map'' f <span class="ot">=</span> unfold <span class="fu">null</span> (f <span class="op">.</span> <span class="fu">head</span>) <span class="fu">tail</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="ot">iterate' ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>iterate' <span class="ot">=</span> unfold (<span class="fu">const</span> <span class="dt">False</span>) <span class="fu">id</span></span></code></pre></div></li>
<li><p>Modify the binary string transmitter example to detect simple transmission errors using the concept of parity bits. That is, each eight-bit binary number produced during encoding is extended with a parity bit, set to one if the number contains an odd number of ones, and to zero otherwise. In turn, each resulting nine-bit binary number consumed during decoding is checked to ensure that its parity bit is correct, with the parity bit being discarded if this is the case, and a parity error being reported otherwise. (Hint: the library function <code>error :: String -&gt; a</code> displays the given string as an error message and terminates the program; the polymorphic result type ensures that error can be used in any context.)</p>
<p>Solution:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bit</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ot">bin2Int ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>bin2Int <span class="ot">=</span> <span class="fu">foldr</span> (\x y <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>y) <span class="dv">0</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="ot">int2Bin ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>int2Bin <span class="dv">0</span> <span class="ot">=</span> []</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>int2Bin n <span class="ot">=</span> <span class="fu">mod</span> n <span class="dv">2</span> <span class="op">:</span> int2Bin (<span class="fu">div</span> n <span class="dv">2</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="ot">make8 ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>make8 bits <span class="ot">=</span> <span class="fu">take</span> <span class="dv">8</span> (bits <span class="op">++</span> <span class="fu">repeat</span> <span class="dv">0</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="ot">encode ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>encode <span class="ot">=</span> <span class="fu">concatMap</span> (make8 <span class="op">.</span> int2Bin <span class="op">.</span> <span class="fu">ord</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="ot">encodeWithParityBit ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>encodeWithParityBit s <span class="ot">=</span> encoded <span class="op">++</span> [parityBit]</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        encoded   <span class="ot">=</span> encode s</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        parityBit <span class="ot">=</span> <span class="fu">sum</span> encoded <span class="ot">`mod`</span> <span class="dv">2</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- Using previously defined chop8 from #6</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="ot">decode ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>decode <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">chr</span> <span class="op">.</span> bin2Int) <span class="op">.</span> chop8</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a><span class="ot">decodeWithParityBit ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>decodeWithParityBit list <span class="ot">=</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="fu">last</span> list <span class="op">==</span> <span class="fu">sum</span> (<span class="fu">init</span> list) <span class="ot">`mod`</span> <span class="dv">2</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> decode <span class="op">$</span> <span class="fu">init</span> list</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="fu">error</span> <span class="st">&quot;Parity bit doesn't match input actual string&quot;</span></span></code></pre></div></li>
<li><p>Test your new string transmitter program from the previous exercise using a faulty communication channel that forgets the first bit, which can be modeled using the tail function on lists of bits.</p>
<p>Solution:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">channelNoisy ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>channelNoisy <span class="ot">=</span> <span class="fu">tail</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ot">transmitNoisy ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>transmitNoisy <span class="ot">=</span> decodeWithParityBit</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span> channelNoisy</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span> encodeWithParityBit</span></code></pre></div></li>
<li><p>Define a function <code>altMap :: (a -&gt; b) -&gt; (a -&gt; b) -&gt; [a] -&gt; [b]</code> that alternately applies its two argument functions to successive elements in a list, in turn about order. For example:</p>
<p>Solution:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> altMap (<span class="op">+</span><span class="dv">10</span>) (<span class="op">+</span><span class="dv">100</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">10</span>,<span class="dv">101</span>,<span class="dv">12</span>,<span class="dv">103</span>,<span class="dv">14</span>]</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">altMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>altMap _ _ [] <span class="ot">=</span> []</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>altMap f g (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> altMap g f xs</span></code></pre></div></li>
<li><p>Using <code>altMap</code>, define a function <code>luhn :: [Int] -&gt; Bool</code> that implements the Luhn algorithm from the exercises in Chapter 4 for bank card numbers of any length. Test your new function using your own bank card.</p>
<p>Solution:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">luhnDouble ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>luhnDouble n</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">5</span>    <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> n</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">9</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="ot">luhn ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>luhn [] <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>luhn ns <span class="ot">=</span> <span class="fu">mod</span> (<span class="fu">sum</span> <span class="op">$</span> altMap luhnDouble <span class="fu">id</span> ns) <span class="dv">10</span> <span class="op">==</span> <span class="dv">0</span></span></code></pre></div></li>
</ol>
</div>
    </div>
</body>

</html>