## 9.1 Introduction

Hutton defines the countdown problem as follows[^1]:

> Given a sequence of numbers and a target number, attempt to construct
> an expression whose value is the target, by combining one or more
> numbers from the sequence using addition, subtraction, multiplication,
> division and parentheses.

An important constraint is that each number can be used at most once,
and that all numbers, both those given and those generated by
intermediate operations, must be positive natural numbers.

## 9.2 Arithmetic operators

We begin by creating a type for our four allowed functions

``` haskell
data Op = Add | Sub | Mul | Div
```

and providing an instance of `Show` for it

``` haskell
instance Show Op where
    show Add = "+"
    show Sub = "-"
    show Mul = "*"
    show Div = "/"
```

In the naive approach we will use at first, we create a function `valid`
which tells us if an application of an `Op` will result in a valid
value, and a function `apply` which performs the given operation.

``` haskell
valid :: Op -> Natural -> Natural -> Bool 
valid Sub x y = x > y
valid Div x y = mod x y == 0
valid _ _ _ = True -- Add and Mul closed on Nats

apply :: Op -> Natural -> Natural -> Natural 
apply Add = (+)
apply Sub = (-)
apply Mul = (*)
apply Div = div
```

A better idea would perhaps be to tightly couple the logic of `apply`
and `validate`, so we do not accidentally call `apply` without first
validating. Alternatively, we could create a more restrictive type which
only allows us to construct valid expressions.

## 9.3 Numeric Expressions

We now create a type to represent expressions and provide it with an
instance for `Show`, similar to what we did for `Op`:

``` haskell
data Expr = Val Natural | App Op Expr Expr

instance Show Expr where
    show (Val n) = show n
    show (App o l r) = brak l ++ show o ++ brak r
      where
        brak (Val n) = show n
        brak e = "(" ++ show e ++ ")"
```

As an example of the output:

``` haskell
> show (App Add (Val 1) (App Mul (Val 2) (Val 3)))
"1+(2*3)"
```

We now create a function which gives us the values in an expression

``` haskell
values :: Expr -> [Natural]
values (Val n) = [n]
values (App _ l r) = values l ++ values r
```

and a function which gives us the result of evaluating an expression

``` haskell
eval :: Expr -> [Natural]
eval (Val n) = [n]
eval (App o l r) = [apply o x y | x <- eval l, y <- eval r, valid o x y]
```

The function `eval` represents failure by returning an empty list:

```haskell
> eval (App Add (Val 2) (Val 3))
[5]
> eval (App Sub (Val 2) (Val 3))
[]
```

Returning a `Maybe` type would have been a better choice, but we would
lose the nicety of using a list comprehension.

## 9.4 Combinatorial functions

We define a few functions to help us easily create all permutations of every element of the power set (well, list) of the given sequence of numbers.

```haskell
subs :: [a] -> [[a]]
subs [] = [[]]
subs (x:xs) = yss ++ map (x:) yss
    where
        yss = subs xs

interleave :: a -> [a] -> [[a]]
interleave x [] = [[x]]
interleave x (y:ys) = (x:y:ys) : map (y:) (interleave x ys)

perms :: [a] -> [[a]]
perms = foldr (concatMap . interleave) [[]]
```

By composing these functions, we can more readily create a function which exhaustively generates each possible solution.

```haskell
choices :: [a] -> [[a]]
choices = concatMap perms . subs
```

## 9.5 Formalizing the problem

We can write a function which tests whether an expression and a list of numbers yields the desired value

```haskell
solution :: Expr -> [Natural] -> Natural -> Bool
solution e ns n = elem (values e) (choices ns) && eval e == [n]
```

## 9.6 Brute force solution

The first attempt we make is the brute-force one, to better get a sense of the shape of the problem.

[^1]: G. Hutton, *Programming in Haskell* 2nd ed., p 111
